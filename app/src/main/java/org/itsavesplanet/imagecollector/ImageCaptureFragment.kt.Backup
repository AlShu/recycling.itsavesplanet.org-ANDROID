package org.itsavesplanet.imagecollector

//import android.app.Fragment
import android.app.Activity
import android.Manifest
import android.content.Context
import android.content.Intent
import android.graphics.SurfaceTexture
import android.support.v4.app.Fragment
import android.os.Bundle
import android.provider.MediaStore
import android.support.v7.app.AlertDialog
import android.view.LayoutInflater
import android.view.ViewGroup
import android.view.View
import android.widget.Button
import android.widget.Toast
import com.karumi.dexter.Dexter
import com.karumi.dexter.MultiplePermissionsReport
import com.karumi.dexter.PermissionToken
import com.karumi.dexter.listener.PermissionRequest
import com.karumi.dexter.listener.multi.MultiplePermissionsListener
import kotlinx.android.synthetic.main.image_capture.view.*
import org.itsavesplanet.imagecollector.Constants.Companion.CAMERA_CAPTURE_IMAGE_REQUEST_CODE
import org.itsavesplanet.imagecollector.Constants.Companion.MEDIA_TYPE_IMAGE
import org.itsavesplanet.imagecollector.R.id.btnCapturePicture
import android.os.HandlerThread
//import android.hardware.camera2.CaptureRequest
//import android.hardware.camera2.CameraCaptureSession
//import android.hardware.camera2.CameraDevice
import android.media.ImageReader
import android.os.Handler
import android.util.Log
import android.util.Size
import android.view.Surface.ROTATION_270
//import sun.text.normalizer.UTF16.append
import android.view.Surface.ROTATION_180
import android.view.Surface.ROTATION_90
import android.view.Surface.ROTATION_0
import android.util.SparseIntArray
import android.view.TextureView
import java.io.File
import android.view.Surface
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.TotalCaptureResult;
import android.hardware.camera2.params.StreamConfigurationMap;


class ImageCaptureFragmentBackup : Fragment() {
    var imageStoragePath: String? = null
    var activity: Activity? = null

    private val TAG = "AndroidCameraApi"
    private val takePictureButton: Button? = null
    private val textureView: TextureView? = null


    private val ORIENTATIONS = SparseIntArray()
//    companion object {
//        init {
//            ORIENTATIONS.append(Surface.ROTATION_0, 90);
//            ORIENTATIONS.append(Surface.ROTATION_90, 0);
//            ORIENTATIONS.append(Surface.ROTATION_180, 270);
//            ORIENTATIONS.append(Surface.ROTATION_270, 180);
//        }
//    }

    private val cameraId: String? = null
    private var cameraDevice: CameraDevice? = null
    private var cameraCaptureSessions: CameraCaptureSession? = null
    private var captureRequest: CaptureRequest? = null
    private var captureRequestBuilder: CaptureRequest.Builder? = null
    private val imageDimension: Size? = null
    private val imageReader: ImageReader? = null
    private val file: File? = null
    private val REQUEST_CAMERA_PERMISSION = 200
    private val mFlashSupported: Boolean = false
    private var mBackgroundHandler: Handler? = null
    private var mBackgroundThread: HandlerThread? = null

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.image_capture, container, false)
    }


    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
//        val btnCapturePicture = findViewById(R.id.btnCapturePicture)
//        btnCapturePicture.setOnClickListener { Log.d(TAG, "onViewCreated(): hello world"); }

        /**
         * Capture image on button click
         */
//        view.findViewById(R.id.btnCapturePicture).setOnClickListener(
//        setContentView(R.layout.activity_main)

        activity = getActivity()



        view.textureView.setSurfaceTextureListener(
            object : TextureView.SurfaceTextureListener {
                override fun onSurfaceTextureAvailable(surface: SurfaceTexture, width: Int, height: Int) {
                    //open your camera here
                    openCamera();
                }

                override fun onSurfaceTextureSizeChanged(surface: SurfaceTexture, width: Int, height: Int) {
                    // Transform you image captured size according to the surface width and height
                }

                override fun onSurfaceTextureDestroyed(surface: SurfaceTexture): Boolean {
                    return false;
                }

                override fun onSurfaceTextureUpdated(surface: SurfaceTexture) {
                }
            }
        )


        view.btnCapturePicture.setOnClickListener(
            View.OnClickListener {
                if (CameraUtils.checkPermissions(activity?.getApplicationContext())) {
                    captureImage()
                } else {
                    requestCameraPermission(MEDIA_TYPE_IMAGE, activity as Activity)
                }
            }
        )
    }




    /**
     * Requesting permissions using Dexter library
     */
    private fun requestCameraPermission(type: Int, activity: Activity) {
        Dexter.withActivity(activity)
            .withPermissions(
                Manifest.permission.CAMERA,
                Manifest.permission.WRITE_EXTERNAL_STORAGE
            )
            .withListener(object : MultiplePermissionsListener {
                override fun onPermissionsChecked(report: MultiplePermissionsReport) {
                    if (report.areAllPermissionsGranted()) {

                        if (type == MEDIA_TYPE_IMAGE) {
                            // capture picture
                            captureImage()
                        }

                    } else if (report.isAnyPermissionPermanentlyDenied()) {
                        showPermissionsAlert()
                    }
                }

                override fun onPermissionRationaleShouldBeShown(
                    permissions: List<PermissionRequest>,
                    token: PermissionToken
                ) {
                    token.continuePermissionRequest()
                }
            }).check()
    }


    /**
     * Capturing Camera Image will launch camera app requested image capture
     */
    private fun captureImage() {
        val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)

        val file = CameraUtils.getOutputMediaFile(MEDIA_TYPE_IMAGE)
        if (file != null) {
            imageStoragePath = file.absolutePath
        }

//        val fileUri = CameraUtils.getOutputMediaFileUri(activity?.getApplicationContext(), file)
        val fileUri = CameraUtils.getOutputMediaFileUri(activity as Context, file)

        intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri)

        // start the image capture Intent
        startActivityForResult(intent, Constants.CAMERA_CAPTURE_IMAGE_REQUEST_CODE)
    }

    /**
     * Alert dialog to navigate to app settings
     * to enable necessary permissions
     */
    private fun showPermissionsAlert() {
        val builder = AlertDialog.Builder(activity as Context)
        builder.setTitle("Permissions required!")
            .setMessage("Camera needs few permissions to work properly. Grant them in settings.")
            .setPositiveButton(
                "GOTO SETTINGS"
            ) { dialog, which -> CameraUtils.openSettings(context) }
            .setNegativeButton("CANCEL") { dialog, which -> }.show()
    }

    /**
     * Activity result method will be called after closing the camera
     */
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) {
        // if the result is capturing Image
        if (requestCode == CAMERA_CAPTURE_IMAGE_REQUEST_CODE) {
            if (resultCode == Activity.RESULT_OK) {
                // Refreshing the gallery
                CameraUtils.refreshGallery(activity as Context, imageStoragePath)

                // successfully captured the image
                // display it in image view
                previewCapturedImage()
            } else if (resultCode == Activity.RESULT_CANCELED) {
                // user cancelled Image capture
                Toast.makeText(
                    activity as Context,
                    "User cancelled image capture", Toast.LENGTH_SHORT
                )
                    .show()
            } else {
                // failed to capture image
                Toast.makeText(
                    activity as Context,
                    "Sorry! Failed to capture image", Toast.LENGTH_SHORT
                )
                    .show()
            }
        }
    }


    /**
     * Display image from gallery
     */
    private fun previewCapturedImage() {
        try {
//            // hide video preview
//            txtDescription.setVisibility(View.GONE)
//            videoPreview.setVisibility(View.GONE)
//
//            imgPreview.setVisibility(View.VISIBLE)
//
//            val bitmap = CameraUtils.optimizeBitmap(BITMAP_SAMPLE_SIZE, imageStoragePath)
//
//            imgPreview.setImageBitmap(bitmap)

        } catch (e: NullPointerException) {
            e.printStackTrace()
        }

    }

    protected fun startBackgroundThread() {
        val mbt = HandlerThread("Camera Background")
        mbt.start()
        mBackgroundThread = mbt
        mBackgroundHandler = Handler(mbt.looper)
    }

    protected fun stopBackgroundThread() {
        try {
            mBackgroundThread?.quitSafely()
            mBackgroundThread?.join()
            mBackgroundThread = null
            mBackgroundHandler = null
        } catch (e: InterruptedException) {
            e.printStackTrace()
        }

    }


    private fun takePicture() {
        val camDev = cameraDevice
        if(null == camDev) {
            Log.e(TAG, "cameraDevice is null");
            return
        }
        val manager = activity?.getSystemService(Context.CAMERA_SERVICE) as CameraManager;
        try {
            val characteristics = manager.getCameraCharacteristics(camDev.getId());
            Size[] jpegSizes = null;
            if (characteristics != null) {
                jpegSizes = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP).getOutputSizes(ImageFormat.JPEG);
            }
            int width = 640;
            int height = 480;
            if (jpegSizes != null && 0 < jpegSizes.length) {
                width = jpegSizes[0].getWidth();
                height = jpegSizes[0].getHeight();
            }
            ImageReader reader = ImageReader.newInstance(width, height, ImageFormat.JPEG, 1);
            List<Surface> outputSurfaces = new ArrayList<Surface>(2);
            outputSurfaces.add(reader.getSurface());
            outputSurfaces.add(new Surface(textureView.getSurfaceTexture()));
            final CaptureRequest.Builder captureBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            captureBuilder.addTarget(reader.getSurface());
            captureBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);
            // Orientation
            int rotation = getWindowManager().getDefaultDisplay().getRotation();
            captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, ORIENTATIONS.get(rotation));
            final File file = new File(Environment.getExternalStorageDirectory()+"/pic.jpg");
            ImageReader.OnImageAvailableListener readerListener = new ImageReader.OnImageAvailableListener() {
                @Override
                public void onImageAvailable(ImageReader reader) {
                    Image image = null;
                    try {
                        image = reader.acquireLatestImage();
                        ByteBuffer buffer = image.getPlanes()[0].getBuffer();
                        byte[] bytes = new byte[buffer.capacity()];
                        buffer.get(bytes);
                        save(bytes);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    } finally {
                        if (image != null) {
                            image.close();
                        }
                    }
                }
                private void save(byte[] bytes) throws IOException {
                    OutputStream output = null;
                    try {
                        output = new FileOutputStream(file);
                        output.write(bytes);
                    } finally {
                        if (null != output) {
                            output.close();
                        }
                    }
                }
            };
            reader.setOnImageAvailableListener(readerListener, mBackgroundHandler);
            final CameraCaptureSession.CaptureCallback captureListener = new CameraCaptureSession.CaptureCallback() {
                @Override
                public void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request, TotalCaptureResult result) {
                    super.onCaptureCompleted(session, request, result);
                    Toast.makeText(AndroidCameraApi.this, "Saved:" + file, Toast.LENGTH_SHORT).show();
                    createCameraPreview();
                }
            };
            cameraDevice.createCaptureSession(outputSurfaces, new CameraCaptureSession.StateCallback() {
                @Override
                public void onConfigured(CameraCaptureSession session) {
                    try {
                        session.capture(captureBuilder.build(), captureListener, mBackgroundHandler);
                    } catch (CameraAccessException e) {
                        e.printStackTrace();
                    }
                }
                @Override
                public void onConfigureFailed(CameraCaptureSession session) {
                }
            }, mBackgroundHandler);
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }
}
